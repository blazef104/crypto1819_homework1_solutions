\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{framed}
\usepackage{amsmath}
\input{macro.tex}

\newcounter{t0d0_counter}
\newcommand{\notodo}[1]{
}
\newcommand{\todo}[1]{
  \stepcounter{t0d0_counter}
  \definecolor{shadecolor}{rgb}{1,1,0} % this is yellow
  \begin{shaded}
  T0D0 \arabic{t0d0_counter}: #1
  \end{shaded}
}


\title{\textbf{Cryptography Homework 1}\\ {\normalsize (Solutions)}}
\author{Giulio Ginesi - 1480066}
\date{}


\begin{document}

\maketitle
\tableofcontents

\section{Perfect Secrecy}
\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}[every text node part/.style={align=center}, scale=0.7]
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{$ \A $}
      \newinst[4]{B}{$ \C $}
      \postlevel
      \mess{A}{$(m_0,m_1)$}{B}
      \postlevel
      \mess{B}{$c$}{A}
      \node[anchor=west] at (mess from) { $k\leftarrow\$ K, b\leftarrow\$\{0,1\}$\\ $c=Enc(k,m_b)$ };
      \postlevel
      \mess{A}{$b'$}{B}
      \node[anchor=west] at (mess to) { output 1 IFF $b'=b$ };
      \postlevel
    \postlevel
    \sdend{}
   \end{tikzpicture}
\end{figure}


From our hypotesis we have that (a): $Pr[Game_{\pi,A}^{eav}=1]=\frac{1}2$ and we want to use the following notion of prefect secrecy (b): $Pr[Enc(K,m_0)=c]=Pr[Enc(K,m_1)=c] $. 

We want to prove that $a \implies b$ and also $ b \implies a $
\\
For the first part $a \implies b$:

The notion (a) can be rewritten as 

$$ Pr[Game=1 | b=0]Pr[b=0]+Pr[Game=1 | b=1]Pr[b=1]=$$
Since $b$ is chosen uniformly between 0 and 1 we have:
$$=\frac{1}{2}Pr[Game=1 | b=0]+\frac{1}{2}Pr[Game=1 | b=1]=$$
$$=\frac{1}{2}(Pr[Game=1 | b=0]+Pr[Game=1 | b=1])$$



\section{Universal Hashing}
 \subsection{point a}
 \subsubsection{(i)}
 We can prove that $t-wise \implies (t-1)-wise$ just by writing down the notion of $t$-wise independence.

 $$ \sum_{i=0}^t{Pr[h_s(x_i)=y_i]} = \sum_{i=0}^{t-1}{(Pr[h_s(x_i)=y_i])}+Pr[h_s(x_t)=y_t]$$

 From the above equation we can see that the $t-1$-wise independence is contained in the $t$ wise one. 

 \subsubsection{(ii)} $$ Pr[h_s(x_0)=y \wedge h_s(x_1)=y \wedge h_s(x_2)=y] = \frac{1}{|y^3|} $$
      
Now for 3 different x: $x_0 \neq x_1 \neq x_2$ the corresponding hash functions are as follows:

$$ h_s(x_0) = S_0 + S_1x_0 + S_2x_0^2 $$
$$ h_s(x_1) = S_0 + S_1x_1 + S_2x_1^2 $$
$$ h_s(x_2) = S_0 + S_1x_2 + S_2x_2^2 $$

$$ Pr_{(S_0,S_1,S_2)\gets Z_q^3}[h(x_0)= \varphi \wedge h(x_1)=\varphi \prime \wedge h(x_2)=\varphi \prime \prime]=$$

$$=Pr_{(S_0,S_1,S_2)\gets Z_q^3}[S_0+S_1x_0+S_2x_0^2=\varphi \wedge S_0+S_1x_1+S_2x_1^2=\varphi \prime \wedge S_0+S_1x_2+S_2x_2^2=\varphi \prime \prime]=$$


\[
=Pr_{(S_0,S_1,S_2)\gets Z_q^3}[
\begin{pmatrix}
	1 & x_0 & x_0^2 \\
	1 & x_1 & x_1^2 \\
	1 & x_2 & x_2^2
\end{pmatrix}
\cdot
\begin{pmatrix}
	S_0 \\
	S_1\\
	S_2
\end{pmatrix}
=
\begin{pmatrix}
\varphi \\
\varphi \prime \\
\varphi \prime \prime
\end{pmatrix}
]=
\]

\[
=Pr_{(S_0,S_1,S_2)\gets Z_q^3}[
\begin{pmatrix}
	S_0 \\
	S_1\\
	S_2
\end{pmatrix}
=
\begin{pmatrix}
	1 & x_0 & x_0^2 \\
	1 & x_1 & x_1^2 \\
	1 & x_2 & x_2^2
\end{pmatrix}^{-1}
\cdot
\begin{pmatrix}
\varphi \\
\varphi \prime \\
\varphi \prime \prime
\end{pmatrix}
]=
\]

$$= \frac{1}{|Z_q^3|}=\frac{1}{q^3}$$

\subsection{part b}
\subsubsection{(i)}

$l = 128 $ what is the minimal min-entropy to achieve $\varepsilon = 2^{-80}$?

$$128 \leq k-(2log2^{80} -2)$$
$$k \geq 286$$

Entropy loss: $\delta = 158$

\subsubsection{(ii)}

If $ k = 238 $ what is the maximum amount of uniform randomness with $\varepsilon = 2^{-80}$?

$$l \leq 238-(2log2^{80}-2)$$
$$l \leq 80$$

Making computational assumptions explain how to obtain $ l = 320 $

Let's assume a large enough $\varepsilon = 2^{-128}$ then our $k$ will be:
$$320 \leq k - (2log2^{128}-2)$$    
$$k \geq 574$$ 

How can we obtain $l=320$ using computational assumptions?
$$320\leq k-(2log(\frac{1}{\varepsilon})-2)$$
I assume a large enough $\varepsilon=2^(128)$ 
$$320\leq k-(2*128-2)$$
$$320\leq k-254$$
$$k\geq574$$

\newpage
\section{One-Way Functions}
\subsection{part a}

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}[scale=0.7]
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{$ \D^\prime $}
      \newinst[4]{B}{$ \D $}
      \newinst[4]{C}{$ \C $} % Increase "5" to widen
      \postlevel
      \mess{C}{$z$}{B}
      \node[anchor=west] at (mess to) {  };
      \node[anchor=west] at (mess from) {$z=G(x)$ or $z=U_{m+1}$};
      \postlevel
      \mess{B}{$z$}{A}
      \postlevel
      \mess{A}{$x^\prime$}{B}
      \node[anchor=west] at (mess to) {  };
      \postlevel
      \mess{B}{$b^\prime$}{C}
      \node[anchor=west] at (mess to) {  };
    \postlevel
    \sdend{}
   \end{tikzpicture}
\end{figure}

Suppose $D^\prime$ is able to invert $G$ with non negligible probability, then $D$ can distinguish in poly time if $z$ comes from $G$ or $U_{n+1}$. 
Upon receiving $x^\prime$ $D$ can compute $G(x^\prime)=z^\prime$.

Now if $z^\prime=z$, $D$ will decide $b^\prime=1$ otherwise $b^\prime=0$.
\todo{THIS IS COMPLETELY WRONG!}
 
\subsection{part b}
\subsubsection{(i)}

By contraddiction assume that $\exists$ a distinguisher $D^\prime_g$ that is able to invert $g$ with non negligible probability (as before).
We will then have:
$$ Pr[g(x^\prime || j)=z : x \leftarrow\$ \{0,1\}^n, z^\prime = g(x), |j|=log(n), x^\prime \leftarrow\$D^\prime_g(1^{\lambda},z)] \geq \frac{1}{p(\lambda)}$$

We can also define another adversary $D^\prime_f$ which is able to invert $f$ with non negligible probability such that:
$$ D^\prime_f(z)=(D^\prime_g(z,j,x_j))$$
Note that $D^\prime_g$ reveals $g$ when taking $(z,j,x_j)$ as input and in the same way, $D^\prime_f$ reveals $f$ on input $z$.
Therefore $D^\prime_f$ leaks f (on input $z$) with the same probability of $D^\prime_g$ which is non negligible. $\implies$ Contraddiction.

\subsubsection{(ii)}

Let $g$ be a OWF then we can define $f$ as follows:
$$ f(U_{n+log(n)})=f(U_n,U_{log(n)})=g(U_n),U_{log(n)},[U_n]_{U_{log(n)}}$$
where $[x\prime]_i$ denote the $i^{th}$ bit of $x\prime$.\\
In words, $f$ receives an input of length $n+log(n)$ and outputs $g$ applied to the first $n$ bits, together with $i$ and the $i^{th}$ bit if the input ( $i$ is the value in the last $log(n)$ bits of the input).\\
Fix $i$, we construct an $A_i$ s.t. $A_i(f(x\prime))$ outputs $x\prime _i$ with $Pr=\frac{1}{2}+\frac{1}{2n}$.
$A_i$ receives $f(U_{n+log(n)})$ and checks the second $log n$ bits of the output:\\
If they encode the value $i$ then $A_i$ outputs these last bits.\\
Otherwise $A_i$ outputs a random bit $b \in {0,1}$. \\
Now 

$$Pr[A_i(f(U_n,U_{log(n)}))=[U_n]_i]=$$
$$=\frac{1}{2}Pr[U_{log(n)} \neq i]+1Pr[U_{log(n)}=i]=$$
$$=\frac{1}{2}(1-\frac{1}{n})=\frac{1}{2}+\frac{1}{2n} > \frac{1}{2} + \frac{1}{2(n+log(n))}$$

We conclude that with inputs of length $n$, $A_i$ succeeds in the guess of $A^{th}$ with $Pr$ at least $\frac{1}{2}+\frac{1}{2n}$.

\todo{Now we just need to prove that $f$ is one way:\\
Assume by contraddiction that $\exists$ a PPT adversary $A$ which can invert $f$ with non negligible probability.\
I think we can draw a figure of the game here (and maybe also above?)}

\section{Pseudorandom Generators}
\subsection{point a}

The two functions $G_{1}$ and $G_{2}$ have two different distributions over
$\{0,1\}^{\lambda + l}$, since one of the two is indistinguishable from uniform
distribution while the other one is not.

Intuitively we can state that the XOR operation preserves the distribution, and therefore the randomness (as we have done when demonstrating OTP). For this reason $G_{1}(.) \xor G_{2}(.)$ has uniform distribution if one of the two is uniformly distributed.

For our problem let's create our new function $G^*$ as: 
$$G^{*}(S_1, S_2)=G_{1}(S_1) \xor G_{2}(S_2)$$
where the seeds $(S_1, S_2) $ are sampled at random over $\lambda$ and $S_1 \neq S_2$.\\

Let's fix $G_{1}$ as our PRG without loss of generality, suppose we can build a PPT distinguisher which is able to tell apart $G_1$ and $U_{\lambda+l}$:

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      \sdbegin{}
      \newinst{A}{$ \D' $}
      \newinst[4]{B}{$ \D $}
      \newinst[2]{C}{$C^{prg}$}
      \postlevel
      \mess{C}{$z$}{B}
      \node[anchor=west] at (mess from) {\shortstack[l]{
            $ z=G_{1}(S_0),$ for $ S_0 \leftarrow\$ U_{\lambda}$ 
            \\or\\
            $ z \leftarrow\$ U_{\lambda + l} $
    }};

      \postlevel
      \mess{B}{$G^{*}=z\xor G_{2}(S_1)$}{A}
      \node[anchor=west] at (mess from) { $S_1\leftarrow\$ U_{\lambda}$ };
            \postlevel
            \mess{A}{$b'$}{B}
            \node[anchor=west] at (mess to) {  };
                  \postlevel
                  \mess{B}{$b'$}{C}
                  \node[anchor=west] at (mess to) {  };
            


      \sdend{}
      \sdend{}
   \end{tikzpicture}
\end{figure}

Now to distinguish between $G^*$ and $U_{\lambda+l}$ means to distinguish between $G_1$ and $U_{\lambda+l}$ (for the xor property discussed before). Hence this is a contraddiction since $G_1$ is a PRG by definition. \\ 
The exact same proof can be repeated if $G_{2}$ is a PRG.

\subsection{point b}

We would like to optimize the seed length (i.e. use the same seed for both functions). On this point I have two considerations:

1) The same seed can't be used since, looking at the above game, it would mean that $D$ must have access to the seed $S$ used by $C$. This is a big problem because with access to this information $D$ can compute both $G_1(S)$ and $G_2(S)$ (the PRGs are public) and therefore will win the Game with probability=1 always.\\

2) There exists an example using a specific construction of $G_{1}=G_{2} \xor 1^{\lambda} $ where $G_1$ is a PRG and therefore also $G_2$ is a PRG.
Hence $G^{*}(S)= G_{2}(S) \xor 1 \xor G_{2}(S) = 1$ which is not a PRG.\\

\todo{Intuition: fixed $G_1$ as the PRG: $G^*=G_1(S_0)\xor G_2(S_0)\xor G_2(S_1)$ this a PRG even when using always the same seed ($G^*=G_1(S)$) however the problem discussed in 1) remains.}

\section{Pseudorandom Functions}
\subsection{point a}
Consider an exponential time/unbounded distinguisher $D$ that,  
\[
\forall \F=\{ F_{k}:
    \{0,1\}^{n(\lambda)} \to \{0,1\}^{l(\lambda)}\}_{k \in \{0,1\}^{\lambda} }
\]
 plays the PRF game with this family of functions :

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      \sdbegin{}
      \newinst{A}{$ \D $}
      \newinst[4]{B}{$ \C^{prf} $}
            \postlevel
            \mess{A}{$x$}{B}
            \node[anchor=west] at (mess to) {  };
           \postlevel
           \mess{B}{$y$}{A}
           \node[anchor=west] at (mess from) {\shortstack[l]{
                       $  y=F_{k}(x)  $ 
                 \\
         $  y=R(x), \text{for }R \leftarrow\$\R(\lambda,n, l)  $ }};
      
      \postlevel
      \mess{A}{$b'$}{B}
      \node[anchor=west] at (mess to) {  };
      \sdend{}
      \sdend{}
   \end{tikzpicture}
\end{figure}

When $\D$ receives $y$, since he is efficient in computing \textit{superpoly}
operations, he can efficiently compute all the possible $F_{k}(x), \forall k
\in \{0,1\}^{\lambda} $.\\
So he can efficiently win the $Game$ for each family of PRF functions.\\

\todo{Maybe here the same ideas of Note 2}

\textbf{Note 1}: it can happen that $\C$ choses $y= R(x)$
which is equal to $F_{k'}(x)$ but not to $F_{k}(x)$($k$ is the key that should
be used in the PRF experiment), for a certain $k' \in  \{0,1\}^{\lambda} $ and
$k'\not= k$.\\ 
Then, $\C$ sends $y$ to $\A$, and $\A$, after finding $k'$ and  $F_{k'}(x)=y$,
thinks that he is playing a \textit{PRF experiment}, while he is actually
playing a \textit{random experiment}. \\
Thus, after sending the related $b'$ to $\C$, $\A$ loses.\\

How many times this \textit{collision}  can happen? In the worst case there are
$2^{\lambda}-1$ possible common values among $F_{(.)}(x)$ and $R(x)$, the number
of "hidden" keys minus the "legal" key chosen for the PRF experiment. So, the
probability that $\C$, using a random function,  extracts a truly random number
and not an $y=F_{k'}(x)$ for some $k'$ "hidden" key is
$\frac{1}{2^{l}-(2^{\lambda}-1)}$.\\
The more large $l$ than $\lambda$ is, the more negligible this probability is.\\



\textbf{Note 2}: It can happen that $\C$ choses an $y=R(x)$ equal to $F_{k}(x)$.
Like before, in this case $\A$ thinks he is playing with a PRF, while he is
actually playing with a truly random function, so $\A$ loses.\\

How many times this \textit{collision}  can happen ? This happens with the
probability of picking
an input $x$ over $|\M|$ possible inputs times the probability of picking a
Random function $R(.)$ which contains a collision exactly for the input $x$ over
all the possible random functions.\\
Since the random functions with a table containing a collision with $F_{k}$
over input $x$ are $ 2^{l 2^{n-1}} $, the probability of picking exactly $x$ and
one of these random functions containing a collision over $x$ is 
\[
    \frac{1}{2^{n}} * \underbrace{\frac{2^{l 2^{n-1}}}{2^{l
2^{n}}}}_{\frac{1}{2}}
\]
which is negligible.
\subsection{point b}
\subsubsection{i}

Suppose that the proposed $F_{k}(.)$ is a PRF. This means that $F_{k}(x)$ for
any x is indistinguishable from $R(x)$, for $R \leftarrow\$ \R(\lambda, n, l)$.\\
Now, given a couple $(x,x')$ such that $x \not= x'$, it should be
\textit{difficult}  to
guess $z=R(x) \xor R(x')$, and \textit{difficult} means that, since there exists
only one $z$ which is the output of the XOR operation, it's possible to pick the
correct one with probability $\frac{1}{2^{l}}$.\\
Otherwise, for a given random couple $(x, x')$, our function produces
    \begin{gather*}
        F_{k}(x)=x \xor G'(k) \wedge F_{k}(x')=x' \xor G'(k) \Rightarrow\\
        \Rightarrow F_{x}(x) \xor F_{k}(x') = \\
        x \xor G'(k) \xor x' \xor G'(k) =\\
        =x \xor x'
    \end{gather*}
and it is possible to correctly guess this result with probability 1. 
So the proposed $F_{k}(.)$ is not totally indistinguishable from a truly random
function.
\subsubsection{ii}
When $F:\{0,1\}^{\lambda}*\{0,1\}^{\lambda} \to \{0,1\}^{l} $ is pseudorandom,
it is distinguishable from the random function
\[
R:\{0,1\}^{\lambda} * \{0,1\}^{\lambda} \to \{0,1\}^{l} 
\]
just for a negligible factor.\\

To prove that $F_{k}(x)=F_{x}(k)$ given is PRF, we should show that
this property holds for every possible PRF $F$.\\
Now consider a function $F'$ with the same definition of $F$, but when $F'$
receives $k=t$ for a fixed $t \leftarrow\$ \{0,1\}^{\lambda} $ it always outputs
$1^{l}$, no matter of what is given as second argument.\\

Since $F'$ behaves like $F$ but for inputs starting with $t$ as prefix, it is
indistinguishable from $R$ until one yields one of these $t-$strings.
Since among all the strings long $\lambda + \lambda$ bits there are $\lambda$
strings which start with the prefix $t$, 
\[
    \P [ \text{ Pick at random a $\lambda + \lambda$ string starting with $t$}
    ]= \frac{1}{2^{\lambda}}  
\]
so $F'$ is distinguishable from $R$ for the negligible factor as for $F$ and for
this negligible factor related to picking $t-$strings at random.
So we can say that $F'$ is a PRF.\\

But now if an attacker sends $t$ to the challenger who uses $F_{k}(x)=F_{x}(k)$,
the attacker can guess with probability 1 if he is playing in an experiment
involving a random function or not, since if the received message from the
challenger is $1^{l}$ the function used is $F'$ (less than a negligible factor,
which is the probability that the random function picks exactly $1^{l}$ for the
given input).
\newpage
\subsubsection{iii}
Let's suppose that , given the PRF $F:\{0,1\}^{n} \to \{0,1\}^{n}$, there
exists a distinguisher $D'$ which can distinguish $F':\{0,1\}^{n-1} \to
\{0,1\}^{2n} $ from a truly random function $R:\{0,1\}^{n-1} \to
\{0,1\}^{2n} $.
But if this is possible, then we have 

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      \sdbegin{}
      \newinst{A}{$ \D' $}
      \newinst[3]{B}{$ \D $}
      \newinst[3]{C}{$\C$}

            \postlevel
            \mess{A}{$x$}{B}
            \node[anchor=west] at (mess to) {  };
            \postlevel
            \mess{B}{$x\|0$}{C}
            \node[anchor=west] at (mess to) {  };
           \postlevel
           \mess{C}{$y_{1}$}{B}
           \node[anchor=west] at (mess from) {\shortstack[l]{
                   $  y_{1}=F_{k}(x\|0)  $ 
                 \\
                 $ y_{1} \leftarrow\$ U_{n} $ }};
            \postlevel
            \mess{B}{$x\|1$}{C}
            \node[anchor=west] at (mess to) {  };
           \postlevel
           \mess{C}{$y_{2}$}{B}
           \node[anchor=west] at (mess from) {\shortstack[l]{
                   $  y_{2}=F_{k}(x\|1)  $ if $F_{k}$ previously used
                 \\
                 $ y_{2} \leftarrow\$ U_{n} $ otherwise }};
      
      \postlevel
      \mess{B}{$y_{1}\|y_{2}$}{A}
      \node[anchor=west] at (mess to) {  };

            \postlevel
            \mess{A}{$b'$}{B}
            \node[anchor=west] at (mess to) {  };
      
            \postlevel
            \mess{B}{$b'$}{C}
            \node[anchor=west] at (mess to) {  };

            \sdend{}((
      \sdend{}
   \end{tikzpicture}
\end{figure}
so we could break the PRF function $F_{k}$, which is impossible by definition.

\newpage
\section{Secret Key Encryption}
\subsection{point a}
We can build a counterexample, to show that this construction is not secure:

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      \sdbegin{}
      \newinst{A}{$\A$}
      \newinst[6]{B}{$ \C $}
            \postlevel
        
            
            \mess{A}{$\overbrace{ v_{1} \xor v_{2}, m_{2_{1}}, \ldots,
                m_{t_{1}}}^{m_{1}^{*}}, \overbrace{v_{1}, m_{2_{1}}, \ldots,
        m_{t_{1}}}^{m_{2}^{*}}$}{B}
            \node[anchor=east] at (mess from) {$v_{1}, v_{2}\not=0^{n} \leftarrow\$ \M $  };
                  \postlevel
              \mess{B}{$\overbrace{c_{0}, c_{1}, \ldots, c_{t}}^{c^{*}}$}{A}
                  \node[anchor=west] at (mess from) {\shortstack[l]{
                              $b \leftarrow\$ \{1,2\} 
                              $
                              \\
                  		$ c_{0} \leftarrow\$ \{0,1\}^{n} 
                  		   $ 
                        \\
                $  c_{i}=P_{k}(c_{i-1} \xor m_{i_{b}})  $ }};
                 \postlevel
                 \mess{A}{$c_{0} \xor v_{2}, c_{1} , \ldots, c_{t-1}, c_{t} $}{B}
                 \node[anchor=west] at (mess to) {  };

                       \postlevel
                       \mess{B}{$m_{1}, m_{2}, \ldots, m_{t}$}{A}
                       \node[anchor=west] at (mess from) {\shortstack[l]{
                                   $ m_{i}= P_{k}^{-1}(c_{i}) \xor
                                   c_{i-1} $ for $i > 1$ 
                             \\
                     $  m_{1}=P_{k}^{-1}(c_{1}) \xor c_{0} \xor v_{2}   $ for $i=1$ }};
                 
      \sdend{}
      \sdend{}
   \end{tikzpicture}
\end{figure}
But $P_{k}^{-1}(c_{1})=c_{0} \xor m_{1_{b}}$.\\

So:
\begin{itemize}
    \item if $b=1$, the received $m_{1}$  contains  $\not c_{0} \xor v_{1} \xor
        \not v_{2} \xor \not c_{0} \xor \not v_{2}= v_{1} $
    \item if $b=2$ the received $m_{1}$ contains $ \not c_{0} \xor v_{1} \xor
        \not c_{0} \xor v_{2}= v_{1} \xor v_{2}$
\end{itemize}
So looking in the first block of the last query we can understand which block
was chosen as first, and we can deduce which message was encrypted (since
$m_{1}^{*}$ and $m_{2}^{*}$ are equal but for the first block).
\newpage
\subsection{point b}

We have the following game as a counterexample for the CCA-security of OFB mode:


\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      \sdbegin{}
      \newinst{A}{$ \A $}
      \newinst[6]{B}{$ \C $}
      \postlevel
      \mess{A}{$\overbrace{ m_{1} \xor v , m_{2} \xor v, \ldots,
              m_{t} \xor v}^{m_{1}^{*}}, \overbrace{m_{1}, m_{2}, \ldots,
        m_{t}}^{m_{2}^{*}} $ }{B}
      \node[anchor=east] at (mess from) { $v \leftarrow\$ \{0,1\}^{n} 
      $ };
      \postlevel
      \mess{B}{$c^{*}=r_{0}^{*}, c_{1}^{*}, \ldots, c_{t}^{*}$}{A}
      \node[anchor=west] at (mess from) {\shortstack[l]{
      		$b\leftarrow\$\{1, 2\} 
      		    $ 
            \\
            $r_{0} \leftarrow\$ \{0,1\}^{n}, r_{i}=F_{k}(r_{i-1}) 
             $
         \\
         $c_{i}= r_{i} \xor m_{i_{b}}$
 }};

      \postlevel
      \mess{A}{$r_{0}, c_{1} \xor v, \ldots, c_{t} \xor v $}{B}
      \node[anchor=east] at (mess from) {  };
      \postlevel
      \mess{B}{$m_{1}, \ldots, m_{t}$}{A}
      \node[anchor=west] at (mess from) {\shortstack[l]{
      		$  m_{i}=r_{i} \xor c_{i} \xor v  $ 
            \\
            $    $ }};



      \sdend{}
      \sdend{}
   \end{tikzpicture}
\end{figure}
Now there are 2 possibilities:
\begin{itemize}
    \item if $b=1$, $m_{i}= r_{i} \xor \overbrace{r_{i} \xor m_{i} \xor
        v}^{c_{i}} \xor v=m_{i}$
    \item if $b=0$, $m_{i}= r_{i} \xor \overbrace{r_{i} \xor m_{i}}^{c_{i}}
        \xor v = m_{i} \xor v$
\end{itemize}
and this allows the Attacker to understand which message was took for
encryption.
\section{Message Authentication}
\todo{}
(b)

Consider the following game form a generic CBC-MAC:

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}[scale=0.7]
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{$ \A $}
      \newinst[6]{B}{$ \C $}
      \postlevel
      \mess{A}{$m$}{B}
      \node[anchor=west] at (mess to) {  };
      \postlevel
      \mess{B}{$\varphi$}{A}
		\node[anchor=west] at (mess from) { };
		\draw[<-] (1.2,-1.9) to[out=240,in=120] (1.2,-3.1);
      \postlevel
		\mess{A}{$(m^\star,\varphi^\star)$}{B}
      \node[anchor=west] at (mess to) {  };
      \postlevel
		\mess{B}{$b^\prime$}{A}
		\node[anchor=west] at (mess from) { };
		\postlevel
    \sdend{}
   \end{tikzpicture}
\end{figure}

(i)
CBC-MAC for VLM is not secure. Consider the following construction:

- Obtain a message $m_0\leftarrow\$\{0,1\}^n$ of 1 block and his Tag $\varphi_0 =F_k(m_0)$
I can construct a message $m^\star=(m_0,m_0\xor \phi_0)$ and a valid Tag $\varphi^\star=\varphi_0$.
In this way when the challenger will verify the message he will compute $\varphi^\star\prime=F_k(m_0\xor\varphi_0\xor\varphi_0)=F_k(m_0)=\varphi_0$. 
And then clearly $\varphi^\star=\varphi^\star\prime$

(ii)
CBC-MAC using randomness as initialization vector. This isn't secure, consider the following construction:

- Obtain 2 messages $m_0, m_1$ with $m_0\neq m_1$ and their tags $\varphi_0=(r_0,F_k(m_0\xor r_0)), \varphi_1=(r_1,F_k(m_1\xor r_1))$.
I can now forge a new message $m^\star=(m_0\xor m_1)$ and a valid Tag $\varphi^\star=(r_1\xor m_0, \varphi_1)$.
When the challenger will verify $\varphi^\star$ he will compute
$\varphi^\star\prime=F_k(m_1\xor m_0\xor r_1\xor m_0)=F_k(m_1\xor r_1)=\varphi_1$
therefore $\varphi^\star\prime=\varphi^\star$.

(iii) 
CBC-MAC that outputs the tag for each block $\varphi=\varphi_1,\varphi_2,...,\varphi_t$ is not secure. Consider the following construction:

- Obtain 2 messages $m_0=(m_{0,1},m_{0,2}), m_1=(m_{1,1},m_{1,2})$, of at least 2 blocks, and their tags 
$\varphi_0=(\varphi_{0,1},\varphi_{0,2}), \varphi_1=(\varphi_{1,1},\varphi_{1,2})$. Now i can construct 
$m^\star=(m_{1,1}, m_{2,1}\xor\varphi_{1,1}\xor\varphi_{2,1})$ and a valid Tag 
$\varphi^\star=(\varphi_{1,1}, \varphi_{2,2})$. When the challenger will verify $\varphi^\star$ he will compute
$\varphi^\star\prime=F_k(m_{1,1}),F_k(m_{2,1}\xor\varphi_{1,1}\xor\varphi_{2,1}\xor\varphi_{1,1})=\varphi_{2,2}$
therefore $\varphi^\star=\varphi^\star\prime$.

\end{document}
